[sublime Markdown 配置](https://blog.csdn.net/qq_20011607/article/details/81370236)

***ctrl+m打开浏览器markdown预览***

[markdown基本语法](https://www.jianshu.com/p/191d1e21f7ed)

[题库](https://m.toutiaocdn.com/group/6768788930197193227/?app=news_article_lite&timestamp=1579396865&req_id=202001190921050101290260402E13A4CB&group_id=6768788930197193227)

#算法
##排序

###归并排序
先分治排序，再两两归并排序，也适用于大数据量排序

###快速排序

对 `3 4 1 2 5` 排序

1. 先从e往前e--找，直到找到一个小于a[b]的数，交换
2. 再从b往后b++找，直到找到一个大于a[e]的数，交换
3. 直到b==e 返回索引b。

```
3 1 4 2 5 6
b         e

3 4 1 2 5 6 发现 2<3 交换
b     e

2 4 1 3 5 6 换b往后找
b     e

2 4 1 3 5 6 发现 4>3 交换
  b   e

2 3 1 4 5 6 换e往前找
  b   e

2 3 1 4 5 6 发现 1<3 交换
  b e

2 1 3 4 5 6 换b往后找
  b e

2 1 3 4 5 6 b==e 结束，3的位置肯定是对的， 2 1 与 4 5 6 递归下
    e
    b
```

```
void main(){
	quickSort(a,0,a.length);
}

void quickSort(int a[],int b,int e){
	int m = quickSortPart(a,0,a.length);
	quickSort(a,b,m-1);
	quickSort(a,m+1,e);
}

int quickSortPart(int a[],int b,int e){
	boolean back = true;
	while(b < e){
		if(a[b]>a[e]){
			swap(a[b],a[e]);
            //  产生了一次交换，改变应该前进的节点
			if(back){
				e--;
			}else{
				b++;
			}
			back=!back;
		}else{
			if(back){
				e--;
			}else{
				b++;
			}
		}
	}
	return b;
}
```

###堆排序
1. 首先用数组表示一个二叉树，`i`节点的左子树为`2i+1`，右子树为`2i+2`
2. 先把堆建好，
3. 排序，每次取出堆头放到数组末尾

```
 static void adjustHeap(int a[], int i, int length) {
        //往子节点遍历,
        for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {
            if (k + 1 < length && a[k + 1] > a[k]) {
                k++;
            }
            // 就是 根节点 左节点 右节点 中最大的当作 根节点
            if (a[k] > a[i]) {
                swap(a, k, i);
                // 如果发生了切换，把子树也调整下
                // 比如 1 3 2, 3变成根节点了, 3 1 2, 那以1为根节点再调整下。
                i = k;
            } else {
                break;
            }
        }
    }

    public static void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
```

#基础知识
###  http https http1.0 http1.1 http2.0
#####http1.0 
每次建立连接都要经历三次握手和滑动窗口慢启动
 
#####http1.1 
1. 更多缓存控制策略供选择 Expires:绝对时间 Cache-Control:3600(绝对时间) 
    * 缓存再验证命中(If-Match)
    * 服务器再验证 (If-Modified-Since,If-None-Match)
2. 请求头新增`range`,支持断点续传
3. `Host`头处理，一台物理主机多虚拟主机共享一个`ip`问题
4. `Keep Alive`，复用Tcp链接
5. 新增错误状态码

#####http2.0
1. 二进制格式
2.  request 多路复用
3.  header 压缩，每次都重复发header头
4.  服务端推送

###  TCP
当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。

* 三次握手
    * 目的
        * 双方都能明确自己和对方的收、发能力是正常的，避免不必要的资源浪费
    * 过程
        1. C 向 S 发 SYN。C进入SYN_SENT。      S得出结论，C的发送能力 S的接受能力正常
        2. S 向 C 发 SYN，ACK。S进入SYN_RCVD。 C得出结论，S的收发能力，C的收发能力正常
        3. C 向 S 回 ACK。 C进入ESTABLISHED，S收到后也进入ESTABLISHED。      S得出结论，C的收发能力，S的收发能力正常
    * 所以至少三次交互，C S 都能确认双方的收发能力正常。比如第三步，光收到数据，S能确定自己的收能力和C的发能力正常，但结合第二步，还能确定自己的发能力和C的收能力正常。

* 四次挥手
    [流程图](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28b49f652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
    * 目的
        * 也是保证双方的收发能力都能正常关闭，避免资源浪费
        * 那为什么是四次呢，因为不同于握手，ACK 和 FIN 无法同时发，要分两次。
    * 过程
        * C发送 FIN 终止数据发送，C进入 FIN_WAIT1 状态
        * S收到FIN，进入CLOSE_WAIT状态。S发送 ACK ，C收到ACK 进入 FIN_WAIT2 状态
        * S发送完数据，S发送FIN ACK，S进入 LAST_ACK 状态
        * C收到FIN，进入TIME_WAIT状态，C发送ACK，过一会进入CLOSED状态(过一会保证这个ACK能发送成功)。S收到ACK，进入CLOSED状态

###  Unicode Utf-8 Utf-16
Unicode包含世界上所有语言的字符集。Utf-8 Utf-16 都属于 Unicode 的实现方式，
* Utf-8 是变长的，用1-4个字节表示一个字符。向下兼容ASCII 
* Utf-16 2个字节或4个字节
定长的编码方便定位

字符数一直在增加
>UTF-16 曾经是可以当定长编码用的，这也是当初会选择他们的主要原因。但是计划比不上变化快，Unicode收录的字符很快就超过了65536个。所以如果还想用定长编码似乎只能采取UTF-32这种编码方式了。可是这种方式最大的问题是即使是英文字母也要四个字节来存储，空间浪费太大了。所以UTF-8这种变长编码方式开始流行起来了，英文字母只需要一个字节，汉字三个字节。更古怪更稀有的字符可以用四个，五个或更多字节表示，因为使用频率低，所以空间浪费不大。当然定长编码的好处是可以快速定位字符，对于string.charAt(index)方法有着较好的支持。UTF-8的话，就需要从头开始一个字符一个字符的解析才行，会慢一点。但是与查询定位相比，顺序输出的情况更多，所以平常也不会感受到效率会比较慢。未来的趋势是UTF-8，文件编码是UTF-8，数据库编码是UTF-8，网络流编码是UTF-8，这样真的能减少很多麻烦，现在想要解决编码问题，统一UTF-8化是最佳解决方案。

### 事务 ACID特性
* 原子性(atomicity)
* 一致性(consistency)
* 隔离性(isolation)
* 持久性(durability)

### MVC MVP MVVM
1. MVC
    * Activity 就是C
2. MVP
    * 核心理念是通过一个抽象的 IView 与真正的View进行解耦    
1. MVVM 
    * Model View ViewModel
    1. 数据驱动
        * 数据变化 ui自动变化
            * 观察者机制
    2. 低耦合度
        * 数据独立于ui
        * 团队协作，一个写view，一个写viewmodel。 代码复用，单元测试
    3. 更新ui
        * 由框架确保在主线程

    * 基本与MVP一致，ViewModel相当于P，唯一的区别就是双向绑定，View的变动自动反应在ViewModel上，反之亦然，这样开发者就不用处理事件和view更新了。（有点像flutter的响应式编程，数据驱动UI）

    [MVVM Light kit](https://www.jianshu.com/p/43ea7a531700)

###  java基础

##### StringBuffer 为什么是线程安全的
` public synchronized StringBuffer append(String str)`

##### Serializable 与 Parcelable
* Parcelable的速度比高十倍以上
* Serializable 接口是一种标识接口（marker interface），这意味着无需实现方法，Java便会对这个对象进行高效的序列化操作。
这种方法的缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。
    * Serializable的系统实现是采用ObjectInputStream和ObjectOutputStream实现
* Parcelable方式的实现原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了

##### 静态代理和动态代理
* 静态代理 
    * 手写
* 动态代理 InvocationHandler
    * 代理的是接口
    * 运行时通过反射动态生成

#####  ThreadLocal
通过ThreadLocalMap实现每个线程独享资源(map key是ThreadLocal对象的弱引用)，`ThreadLocalMap`使用开发地址法解决hash冲突，不同于`HashMap`的`链地址法`。
会有key为null，value有值导致的内存泄漏，set完要remove。

#####  ConcurrentHashMap
* 分段锁
    * 不锁全表，只锁一部分
    * jdk1.7的实现，1.8有所变化。ConcurrentHashMap 有 N 个 Segment，每个Segment维护一段区域的 hashcode，Segment本身继承ReentrantLock
        * ReentrantLock
            * 可重入，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放(重入锁)
            * 可中断，可限时，等了一会还拿不到锁，可以选择放弃
            * 公平锁，先来肯定先得锁

##### TreeMap 
* 实现原理 
    * 红黑树 保证有序
* put get O(logn)的复杂度

##### LinkedHashMap 
* 实现原理 
    * 在HashMap的基础上又维护了一个双向链表来保证插入顺序

####线程

##### 如何控制某个方法允许并发访问线程的个数？
使用信号量 Semaphore ，信号量个数变为负数时，再次请求的时候就会阻塞

##### sleep wait yield 区别
* wait会让线程释放掉这个同步代码块的管程身份和锁
* yield 只是让当前线程尝试让出cpu的使用权而已

### JVM
java 有 java语言规范 和 java 虚拟机规范，所以有大批语言能在 java 虚拟机上运行，比如 kotlin，groovy。
java 虚拟机只认 class 文件，字节码。

##### 弱引用 软引用
* 软引用，在GC时，只有内存不足时才回收。所以图片框架的内存缓存用的是软引用。
* 弱引用，GC时就回收，无论内存足不足

##### GC
新生代，老生代，永久代。
每代GC策略不一样，内存达到阈值，GC整理空间

怎么判断垃圾

* 引用计数法
* 可达性分析法

垃圾回收算法

* 标记-清除
    * 碎片多
* 标记-整理
* 复制法
    * 将可用内存分为两块，A用完了，把A的整理复制给B，然后重新将可用内存分为两块。
* 分代收集
    * 目前jvm普遍采用的算法
    * 新生代使用 复制法
    * 老生代使用 标记整理

#####jvm内存模型

* 线程共享
    * 方法区
        * 类信息，常量，静态变量
        * 属于持久代
    * 堆
        * 字符串常量池
* 线程私有
    * 程序计数器
    * 虚拟机栈
    * 本地方法栈
        * 为native方法服务

#####类加载过程 5个步骤
1. 加载
    1. 获取类的字节流
        * 无论你用什么方法获取，可以从jar包，也可以从网络，也可以动态代理生成这个类
    2. 静态存储结构存入方法区 
    3. 生成该类的 `java.lang.Class` 对象
2. 验证
    * 确保该class符合虚拟机标准
3. 准备
    * static初始化，存到方法区
    * 比如 `static int a = 99` 此时a还是0
4. 解析
    * 将常量池的符号引用替换为直接引用
        * [符号引用与直接应用](https://dazi.kukuw.com/art_show_2044154.html),比如A类引用了B类，在未加载B类前，A类不知道B类的内存地址，所以只能用符号引用表示
    * 分派就是多态的体现    
5. 初始化        
    * 将 `a=99`

#####双亲委派机制
>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去加载，每一层次的类加载器都是如此，因此所有的加载请求最终都应传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载

* 好处
    * 防止核心类被篡改

#####ClassLoader们
1. 启动类加载器 BootstrapClassloader
    * 负责加载 <JAVA_HOME>/lib 下核心库，入rt.jar
2. 扩展类加载器 ExtensionClassloader
    * 负责加载 <JAVA_HOME>/lib/ext 下的类库
3. 应用程序加载器 AppClassloader
    * 负责加载 Classpath

##### 断点调试原理
修改断点处的程序指令，加入INT3中断指令。
当前用户态程序发生中断，内核向当前程序发送SIGTRAP信号，当前进程挂起。
调试器进程 与 程序进程 通过 JDWP(Java Debug Wire Protocol,定义了调试器（debugger）和被调试的 Java 虚拟机（target vm）之间的通信协议)进行通信。

#Android
### 基础

##### 本地广播 全局广播的区别
1. LocalBroadcastReceiver仅在自己的应用内发送接收广播，也就是只有自己的应用能收到，数据更加安全广播只在这个程序里，而且效率更高

##### ContentProvider是如何实现数据共享的
1. 使用Uri标识，提供统一的增删改查接口
2. 通过Binder进程间通信机制来控制，同时，它又以匿名共享内存作为数据传输媒介，从而提供了一种高效的数据共享方式。
3. 将要传输的共享数据抽象成一个游标窗口 Cursor Window，内部包含一块匿名共享内存。通过binder将共享内存MemoryFile的fd传出去。

###  OOM
`ActivityManager.getMemoryClass()`可以用来查询当前应用的Heap Size阈值
OOM是剩余的可分配的堆内存不足时触发，本质上是强引用的对象们占用的内存过大。

1. 减小对象的内存占用
    * ArrayMap SparseArray(key是int，避免自动装箱) 替代 HashMap 
        * SparseArray 两个数组，int[] keys，有序，根据二分查找确认key的位置
        * ArrayMap 两个数组 `int[n] mHashs`(存key的hash值，二分查找),`Object[2*n] mValues`
    * Bitmap的内存占用，采样率+像素格式
2. 对象的复用
    * Bitmap 复用 inBitmap属性
    * 避免在频繁调用的方法里new对象，例如 onDraw onBind，避免内存抖动，频繁GC
    * StringBuilder 代替 +
3. 避免内存泄漏
    * 匿名内部类导致的泄漏
    * Handler导致的泄漏
    * Cursor File未及时关闭导致的泄漏
    * 擅于使用弱饮用，软引用
    * LeakCanary原理
        * 使用 WeakReference 来判断对象有没有被回收
4. 内存使用策略优化
    * `onLowMemory` `onTrimMemory` 利用好
    * PB优化，混淆优化
    * 编码上要控制好每个对象的生命周期

#####工程中的经验
* 先阐述 OOM 难以解决的原因
* 使用 `com.squareup.haha:haha:2.0.3` 分析 hprof 内存快照，提高效率
* 线上的OOM 充分挖掘其特征，尽量匹配这些特征尝试复现场景
* 微信的`Matrix` hprof 进行裁剪，自动化分析
* Native泄漏 `asan` `valgrind` 
* 自己兜底总比被系统干掉好
* 方向是 逐步提升自动化程度从而提升发现问题的效率，更应该强调预防

###  ANR（AppNotResponse）

分析 `/data/anr/trace.txt`，监控这个文件，监听anr广播，上传分析
分析 `/data/system/dropbox`，DropBoxManager CPU使用情况和进程trace文件信息

#####分类
1. InputDispatching Timeout 按键或触摸事件无响应
2. Service Broadcast ContentProvider Timeout

表象是主线程的耗时操作引起，但引起耗时的原因很多

1. CPU 满负荷，I/O阻塞
2. GC 导致的挂起

#####原理
[看GitYuan](http://gityuan.com/2019/04/06/android-anr/)

1. system_server埋炸弹
2. 目标完成任务后请求拆炸弹
3. system_server保留现场，引爆炸弹

#####input超时机制
1. `InputReader`监听`/dev/input`读取输入事件
2. 将事件交给`InputDispatcher`
3. `InputDispatcher` 分发给窗口，有 in out wait 三个队列记录事件的分发进度
4. 从 in->out 会检测上一次的 pending 是否超时 (所以第N次输入超时，需要N+1次输入来触发)
5. 若未超时，通过Socket通知app进程干活，并 out->wait

>有哪些路径会引发ANR? 答应是从埋下定时炸弹到拆炸弹之间的任何一个或多个路径执行慢都会导致ANR（以service为例），
可以是service的生命周期的回调方法(比如onStartCommand)执行慢，
可以是主线程的消息队列存在其他耗时消息让service回调方法迟迟得不到执行，
可以是SP操作执行慢，
可以是system_server进程的binder线程繁忙而导致没有及时收到拆炸弹的指令。
另外ActivityManager线程也可能阻塞，出现的现象就是前台服务执行时间有可能超过10s，但并不会出现ANR。

>发生ANR时从trace来看主线程却处于空闲状态或者停留在非耗时代码的原因有哪些？可以是抓取trace过于耗时而错过现场，可以是主线程消息队列堆积大量消息而最后抓取快照一刻只是瞬时状态

###  启动速度优化
1. 先了解Application的启动过程, `Activity onCreate`过程
    * 但这些也不可控
    * 还有个暖启动
2. 评估启动时间 
    * `Application onCreate` -> `onWindowFocusChanged` 首帧
    * `Display`关键字的log
    * `adb shell am start -W com.zq.live/.MainActivity` 还可以测量竞品
    * `adb shell screenrecord` 录屏分析
3. 找出耗时函数
    * TraceView 
        * `startMethodTracing("启动耗时")` `stopMethodTracing()`  
        * 开销大，会把所有的线程的堆栈调用情况都记录下来。可能会使不耗时的方法也表现耗时
    * Systrace
        * `Trace.beginSection("启动耗时")` `Trace.endSection()`  
        * 开销小，只记录区间，
4. 解决方案
    * 根据业务对第三方库的初始化时机进行分类 
    * 对于必须启动时初始化的任务，梳理初始化任务的有向无环依赖图(类似gradlew的并行编译),`CountDownLatch`解决同步 A B 都执行完，执行 C 的问题。
    * 利用好 `idleHandle`
        * 主页面viewstub 懒加载
        * 加载一下第三方库

5. 其他经验
    * 透明动画
    * 拦截back替换成home 
    * IntentService后台初始化库
        * 继承自Service在内部创建HandlerThread
    * 统计每个版本的启动耗时，查看版本diff
    * `com.github.zeshaoaaa:LaunchStarter:0.0.1`
    * 5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了
        * dex-opt过程
            * inline
                * 减少了压栈出栈
                * 编译器可对替换后的上下文进一步优化
                * 减少了缺页中断
            * quick指令优化
    * 支付宝经验
        * 重排apk，将apk中启动要用到的资源排在一起，增大分页cache命中的概率

###  WatchDog
Watchdog是一个运行在system_server进程的名为”watchdog”的线程，用来检测系统服务是否发生死锁的
Watchdog运作过程，当阻塞时间超过1分钟则触发一次watchdog，会杀死system_server,触发上层重启
实现 `Watchdog.Monitor` 就能被加入 WatchDog监控，
监控原理就是向被监控的线程的Handler的消息队列中post一个任务

###  touch 事件分发机制
三个关键方法
1. dispatchTouchEvent
    * 事件分发
2. onInterceptTouchEvent
    * 事件拦截
    * 只有ViewGroup有这个方法，其他两个 View Activity都有
3. onTouchEvent
    * 事件响应

事件分发图 
![隧道机制](http://gityuan.com/images/touch/touch1.jpg)

以ViewGroup为例

    public boolean dispatchTouchEvent(MotionEvent ev) { 

    ... // 仅贴出关键代码

        // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件
            if (disallowIntercept || !onInterceptTouchEvent(ev)) {  

            // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent（）修改
            // 判断值2： 自己是否拦截
            // 即如果 自己不拦截 或者 不允许我拦截 则进入里面

                ev.setAction(MotionEvent.ACTION_DOWN);  
                final int scrolledXInt = (int) scrolledXFloat;  
                final int scrolledYInt = (int) scrolledYFloat;  
                final View[] children = mChildren;  
                final int count = mChildrenCount;  

        // 重点分析2
            // 通过for循环，遍历了当前ViewGroup下的所有子View
            for (int i = count - 1; i >= 0; i--) {  
                final View child = children[i];  
                if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE  
                        || child.getAnimation() != null) {  
                    child.getHitRect(frame);  

                    // 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View
                    // 若是，则进入条件判断内部
                    if (frame.contains(scrolledXInt, scrolledYInt)) {  
                        final float xc = scrolledXFloat - child.mLeft;  
                        final float yc = scrolledYFloat - child.mTop;  
                        ev.setLocation(xc, yc);  
                        child.mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  

                        // 条件判断的内部调用了该View的dispatchTouchEvent()
                        // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）
                        if (child.dispatchTouchEvent(ev))  { 

                        mMotionTarget = child;  
                        return true; 
                        // 调用子View的dispatchTouchEvent后是有返回值的
                        // 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立
                        // 于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出
                        // 即把ViewGroup的点击事件拦截掉

                                }  
                            }  
                        }  
                    }  
                }  
            }  
            boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
                    (action == MotionEvent.ACTION_CANCEL);  
            if (isUpOrCancel) {  
                mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;  
            }  
            final View target = mMotionTarget;  

        // 重点分析3
        // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true）
        if (target == null) {  
            ev.setLocation(xf, yf);  
            if ((mPrivateFlags & CANCEL_NEXT_UP_EVENT) != 0) {  
                ev.setAction(MotionEvent.ACTION_CANCEL);  
                mPrivateFlags &= ~CANCEL_NEXT_UP_EVENT;  
            }  
            
            return super.dispatchTouchEvent(ev);
            // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()
            // 因此会执行ViewGroup的onTouch() ->> onTouchEvent() ->> performClick（） ->> onClick()，即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（））
            // 此处需与上面区别：子View的dispatchTouchEvent（）
        } 

        ... 

### View 的绘制流程
* 底层是以固定的频率16.6ms发出 VSync 信号的
* 跟 View 刷新有关的操作最终也都会层层走到 ViewRootImpl 中的 scheduleTraversals() 方法里。DecorView的parent也是ViewRootImpl
* View 的测量、布局、绘制三大流程都是交由 ViewRootImpl 发起，而且还都是在 performTraversals() 方法中发起的，所以这个方法的逻辑很复杂，因为每次都需要根据相应状态判断是否需要三个流程都走，有时可能只需要执行 performDraw() 绘制流程，有时可能只执行 performMeasure() 测量和 performLayout() 布局流程（一般测量和布局流程是一起执行的）。不管哪个流程都会遍历一次 View 树，所以其实界面的绘制是需要遍历很多次的，如果页面层次太过复杂，每一帧需要刷新的 View 又很多时，耗时就会长一点。

所以如果app都用fragment实现的，这个 performTraversals 会有性能问题

>
FrameDisplayEventReceiver继承自DisplayEventReceiver接收底层的VSync信号开始处理UI过程。VSync信号由**SurfaceFlinger**实现并定时发送。FrameDisplayEventReceiver收到信号后，调用onVsync方法组织消息发送到主线程处理。这个消息主要内容就是run方法里面的doFrame了，这里mTimestampNanos是信号到来的时间参数。

* 同步屏障消息 Choreographer异步消息标记 确保遍历绘制view tree第一时间执行，页面不掉帧
* 即使再小的 View，如果发起了重绘的请求，那么也需要先层层（不停找parent view）走到 ViewRootImpl 里去

![view刷新时序图](https://upload-images.jianshu.io/upload_images/1924341-26227e967f4d3506.png)

### handler 底层

### Application Activity 启动过程整理

### binder



#管理维度：
6、招聘的时候如何识别一个人
9、职业发展的瓶颈
10、遇到的最大的挑战  
    撕歌作为唱歌类社交app ，唱歌体验优化，伴奏失败，无法打分，先打点监控失败率，分析失败原因
    
11、作为一个10个人的Android team Leader 最应该关注哪些事

启动优化、组件化方面的知识

还有管理方面也看看，一般管理就是定目标，做技术规划，团队规划啊
目标怎么制定，团队人员如何培养

不会的东西不要直接说不会，真不会，从逻辑上根据自己的信息去推理

主要你来这边聊一定要表现的特别
让人觉得你是个有想法，有行动力的人
清楚知道自己的优缺点，未来的努力方向