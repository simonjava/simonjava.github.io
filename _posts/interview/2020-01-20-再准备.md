[sublime Markdown 配置](https://blog.csdn.net/qq_20011607/article/details/81370236)

***ctrl+m打开浏览器markdown预览***

[markdown基本语法](https://www.jianshu.com/p/191d1e21f7ed)

[题库](https://m.toutiaocdn.com/group/6768788930197193227/?app=news_article_lite&timestamp=1579396865&req_id=202001190921050101290260402E13A4CB&group_id=6768788930197193227)

#算法
##排序

###归并排序
先分治排序，再两两归并排序，也适用于大数据量排序

###快速排序

对 `3 4 1 2 5` 排序

1. 先从e往前e--找，直到找到一个小于a[b]的数，交换
2. 再从b往后b++找，直到找到一个大于a[e]的数，交换
3. 直到b==e 返回索引b。

```
3 1 4 2 5 6
b         e

3 4 1 2 5 6 发现 2<3 交换
b     e

2 4 1 3 5 6 换b往后找
b     e

2 4 1 3 5 6 发现 4>3 交换
  b   e

2 3 1 4 5 6 换e往前找
  b   e

2 3 1 4 5 6 发现 1<3 交换
  b e

2 1 3 4 5 6 换b往后找
  b e

2 1 3 4 5 6 b==e 结束，3的位置肯定是对的， 2 1 与 4 5 6 递归下
    e
    b
```

```
void main(){
	quickSort(a,0,a.length);
}

void quickSort(int a[],int b,int e){
	int m = quickSortPart(a,0,a.length);
	quickSort(a,b,m-1);
	quickSort(a,m+1,e);
}

int quickSortPart(int a[],int b,int e){
	boolean back = true;
	while(b < e){
		if(a[b]>a[e]){
			swap(a[b],a[e]);
            //  产生了一次交换，改变应该前进的节点
			if(back){
				e--;
			}else{
				b++;
			}
			back=!back;
		}else{
			if(back){
				e--;
			}else{
				b++;
			}
		}
	}
	return b;
}
```

###堆排序
1. 首先用数组表示一个二叉树，`i`节点的左子树为`2i+1`，右子树为`2i+2`
2. 先把堆建好，
3. 排序，每次取出堆头放到数组末尾

```
 static void adjustHeap(int a[], int i, int length) {
        //往子节点遍历,
        for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {
            if (k + 1 < length && a[k + 1] > a[k]) {
                k++;
            }
            // 就是 根节点 左节点 右节点 中最大的当作 根节点
            if (a[k] > a[i]) {
                swap(a, k, i);
                // 如果发生了切换，把子树也调整下
                // 比如 1 3 2, 3变成根节点了, 3 1 2, 那以1为根节点再调整下。
                i = k;
            } else {
                break;
            }
        }
    }

    public static void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
```

#基础知识
### 1 http https http1.0 http1.1 http2.0
####http1.0 
每次建立连接都要经历三次握手和滑动窗口慢启动
 
####http1.1 
1. 更多缓存控制策略供选择 Expires:绝对时间 Cache-Control:3600(绝对时间) 
    * 缓存再验证命中(If-Match)
    * 服务器再验证 (If-Modified-Since,If-None-Match)
2. 请求头新增`range`,支持断点续传
3. `Host`头处理，一台物理主机多虚拟主机共享一个`ip`问题
4. `Keep Alive`，复用Tcp链接
5. 新增错误状态码

####http2.0
1. 二进制格式
2.  request 多路复用
3.  header 压缩，每次都重复发header头
4.  服务端推送

### 2 ThreadLocal
通过ThreadLocalMap实现每个线程独享资源(map key是ThreadLocal对象的弱引用)，`ThreadLocalMap`使用开发地址法解决hash冲突，不同于`HashMap`的`链地址法`。
会有key为null，value有值导致的内存泄漏，set完要remove。

### 3 弱引用 软引用
软引用，在GC时，只有内存不足时才回收。所以图片框架的内存缓存用的是软引用。
弱引用，GC时就回收，无论内存足不足

### 4 GC
新生代，老生代，永久代。
每代GC策略不一样，内存达到阈值，GC整理空间。

#Android
### 1. OOM
`ActivityManager.getMemoryClass()`可以用来查询当前应用的Heap Size阈值
OOM是剩余的可分配的堆内存不足时触发，本质上是强引用的对象们占用的内存过大。

1. 减小对象的内存占用
    * ArrayMap SparseArray(key是int，避免自动装箱) 替代 HashMap 
        * SparseArray 两个数组，int[] keys，有序，根据二分查找确认key的位置
        * ArrayMap 两个数组 `int[n] mHashs`(存key的hash值，二分查找),`Object[2*n] mValues`
    * Bitmap的内存占用，采样率+像素格式
2. 对象的复用
    * Bitmap 复用 inBitmap属性
    * 避免在频繁调用的方法里new对象，例如 onDraw onBind，避免内存抖动
    * StringBuilder 代替 +
3. 避免内存泄漏
    * 匿名内部类导致的泄漏
    * Handler导致的泄漏
    * Cursor File未及时关闭导致的泄漏
    * 擅于使用弱饮用，软引用
4. 内存使用策略优化
    * `onLowMemory` `onTrimMemory` 利用好
    * PB优化，混淆优化
    * 编码上要控制好每个对象的生命周期

####工程中的经验
先阐述 OOM 难以解决的原因
使用 `com.squareup.haha:haha:2.0.3` 分析 hprof 内存快照，提高效率
线上的OOM 充分挖掘其特征，尽量匹配这些特征尝试复现场景
微信的`Matrix` hprof 进行裁剪，自动化分析
Native泄漏 `asan` `valgrind` 
自己兜底总比被系统干掉好
方向是 逐步提升自动化程度从而提升发现问题的效率，更应该强调预防

### 2. ANR（AppNotResponse）

分析 `/data/anr/trace.txt`，监控这个文件，监听anr广播，上传分析
分析 `/data/system/dropbox`，DropBoxManager CPU使用情况和进程trace文件信息

#####分类
1. InputDispatching Timeout 按键或触摸事件无响应
2. Service Broadcast ContentProvider Timeout

表象是主线程的耗时操作引起，但引起耗时的原因很多

1. CPU 满负荷，I/O阻塞
2. GC 导致的挂起

#####原理
[看GitYuan](http://gityuan.com/2019/04/06/android-anr/)

1. system_server埋炸弹
2. 目标完成任务后请求拆炸弹
3. system_server保留现场，引爆炸弹

>有哪些路径会引发ANR? 答应是从埋下定时炸弹到拆炸弹之间的任何一个或多个路径执行慢都会导致ANR（以service为例），
可以是service的生命周期的回调方法(比如onStartCommand)执行慢，
可以是主线程的消息队列存在其他耗时消息让service回调方法迟迟得不到执行，
可以是SP操作执行慢，
可以是system_server进程的binder线程繁忙而导致没有及时收到拆炸弹的指令。
另外ActivityManager线程也可能阻塞，出现的现象就是前台服务执行时间有可能超过10s，但并不会出现ANR。

>发生ANR时从trace来看主线程却处于空闲状态或者停留在非耗时代码的原因有哪些？可以是抓取trace过于耗时而错过现场，可以是主线程消息队列堆积大量消息而最后抓取快照一刻只是瞬时状态

######input超时机制
1. `InputReader`监听`/dev/input`读取输入事件
2. 将事件交给`InputDispatcher`
3. `InputDispatcher` 分发给窗口，有 in out wait 三个队列记录事件的分发进度
4. 从 in->out 会检测上一次的 pending 是否超时 (所以第N次输入超时，需要N+1次输入来触发)
5. 若未超时，通过Socket通知app进程干活，并 out->wait

### 3. 启动速度优化
### 4. WatchDog
Watchdog是一个运行在system_server进程的名为”watchdog”的线程，用来检测系统服务是否发生死锁的
Watchdog运作过程，当阻塞时间超过1分钟则触发一次watchdog，会杀死system_server,触发上层重启
实现 `Watchdog.Monitor` 就能被加入 WatchDog监控，
监控原理就是向被监控的线程的Handler的消息队列中post一个任务

管理维度：
6、招聘的时候如何识别一个人
9、职业发展的瓶颈
10、遇到的最大的挑战  
    撕歌作为唱歌类社交app ，唱歌体验优化，伴奏失败，无法打分，先打点监控失败率，分析失败原因
    
11、作为一个10个人的Android team Leader 最应该关注哪些事

启动优化、组件化方面的知识

还有管理方面也看看，一般管理就是定目标，做技术规划，团队规划啊
目标怎么制定，团队人员如何培养

不会的东西不要直接说不会，真不会，从逻辑上根据自己的信息去推理

主要你来这边聊一定要表现的特别
让人觉得你是个有想法，有行动力的人
清楚知道自己的优缺点，未来的努力方向