---
layout: post
category : LeetCode
tagline: "Java知识点笔记"
tags : [面试,Java,笔记,随手记]
---
{% include JB/setup %}

<h4>{{page.title|remove_first:'Leetcode之'}}</h4>

1. **Java内部类** ，首先，`static class`静态类一定是作为内部类出现的。
	 * 成员变量和方法的定义上，如果内部类不被定义成静态内部类，那么在这个类中是不能定义静态方法的。定义静态成员变量也只能用 `static final int a=0` 必须加 `final`。 
	 * 成员的引用上，非静态内部类，可以随意访问外部类的成员和方法。
	 静态内部类只能访问外部类的静态成员和方法。内部类中的this指的是内部类的实例对象本身，如果要用外部类的实例对象就可以用类名.this的方式获得。
	 *  创建静态内部类时不需要将静态内部类的实例绑定在外部类实例上。
	 非静态内部类是需要绑定外部类实例的，可以将非静态内部类看成外部类的一个非静态成员变量。
	 *  局部内部类，在方法内定义一个类。局部内部类的地位和方法内的局部变量的位置类似，因此不能修饰局部变量的修饰符也不能修饰局部内部类，譬如public、private、protected、static、transient等。

2. **`final method`**:无法被覆盖的方法，尝试在子类中定义同名方法覆盖，编译器会报错。`private method`:子类不会覆盖这个方法，也访问不到这个方法，可以当做子类不知道这个方法。。以上两个关键字对重载都没有影响。

3. **Java堆与栈**
	* 每个线程拥有一个栈。
	* Java的方法参数只能是基本变量和对象引用。这两样都保存在栈中。
	* 引用所指的对象保存在堆中。引用值为`Null`时，不指向任何对象。将引用设为`Null`可协助垃圾回收。
	*  栈可以自理。堆不行，垃圾回收主要也是针对堆内存。

4. **Java垃圾回收** [一篇很好的文章](http://www.cnblogs.com/vamei/archive/2013/04/28/3048353.html)
	* 早期垃圾回收采用*引用计数*。无法解决*循环引用*问题，即两个对象只互相引用。
	* 如何解决*循环引用*问题。以栈和`static`数据为根，从根出发，找到所有可到达的对象。其余对象即为“垃圾”。
	* 具体JVM的垃圾回收是多种机制的混合。
	* “mark and sweep” 和 “copy and sweep”两种清理对内存的方式。
	* 垃圾回收中一个现象。“富人越富，穷人越穷”，世代越久的对象，越不容易被回收。

5. **值传递和引用传递** 

	网上众说纷纭。现声明：*Java只有值传递，没有引用传递*。就算传递一个对象，更准确说是传递栈中对象的引用，也是传递引用的值，即方法中的引用只是你传递进去引用的一个副本，只是两者指向的地址(即对象在堆中的位置)一样而已。

6. sleep wait区别
	
	sleep仍然占着cpu资源，wait会释放资源，线程阻塞，一般不加时间限制，等待其他线程唤醒。
	sleep是静态方法，就算main调用b.sleep也是main在睡觉。

7. 软引用、弱引用
	
	软引用内存够就暂时不回收
	弱引用内存不管够不够已扫描到就回收

8. volatile：保证变量的可见性

9. java lock
	
	http://www.blogjava.net/BucketLi/archive/2010/09/30/333471.html

10. java gc 垃圾回收相关
	